## 2.22

#### 1.jdk1.5后自动封箱考察

```java
Integer i01 = 59;
int i02 = 59;
Integer i03 = Integer.valueOf(59);
Integer i04 = new Integer(59);
```

分析：i01自动封箱为int类型，i03中Integer.valueOf(59)返回值为Integer类型，所有i03为一个Integer对象，i04也是一个Integer对象，两个对象用“==”比较会比较地址，所有“i03==i04”结果为false，int类型与Integer比较时比较数值。

#### 2.关于HashMap和HashTable

a.HashMap支持null作为key和value，HashTable不支持

b.两者都是key-value的存储形式

c.HashMap是线程不安全的，里面的方法没有Synchronized修饰，所以多线程使用时需要提供外同步，HashTable不需要，它的方法都是经过Synchronized修饰的，但是正因为如此，HashTable的效率比较低

d.迭代HashMap采用的是快速失败机制，而HashTable不是

##### 快速失败机制

对于线程不安全的集合的迭代器，如果在使用迭代器的过程中其它线程修改了集合的结构或元素数量，那么会抛出ConcurrentModificationException，这就是所谓的fail-fast策略。但是并不是一定抛出，是有可能。



