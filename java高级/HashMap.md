# HashMap

## 基础

##### 1.核心数据结构

​	HashMap底层是最核心的数据结构是数组，取key的hash值，然后对数组长度取模，结果即为在数组中的索引，该索引中有值即为hash冲突。

##### 2.hash值的优化

​	HashMap底层对取key的hash值进行了优化：
- key为null，则hash值为0；
- key不为null，取key的hashCode()为h(int类型,32位)，在和h右移16位(即前16位全置为0,后16位置为原前16位)做异或运算(^)[^1]；这样做的目的是为了使hash值充分均匀，。

​	HashMap底层取hash的优化源码如下（JDK1.8）：


```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

##### 3.寻址优化

​	HashMap底层在key的hash值对数字长度进行取模得索引进行了改造，现在的寻址操作并不是对key取模找索引，而是用**与运算(&)[^2]等代替取模运算**，提高运算性能，这是因为在计算机的运算中`与运算`效率远高于`取模运算`。且在数组长度为2的n次方情况下进行的`与运算`结果等同于`取模运算`。

与运算公式（其中的hash为优化过的hash值，n为数字长度）：

```
(n - 1) & hash
```

##### 4.hash冲突

​	当多个key的hash寻址操作中求得数组的索引一样时，就称为**hash冲突**或**hash碰撞**，jdk1.8对此的解决方法是链表+红黑树，即在求得相同的数组索引下建一个链表，当这个链表长度达到一定值（**8**）后修改为红黑树。

​	在jdk1.7及以前，新来的hash冲突元素是放在链头，1.8后改成了链尾（待补充原因）。

​	红黑树是一种平衡二叉查找树，是jdk1.8后引入的。红黑树的特点主要有四点：①每个节点非黑即红②根节点和叶节点一定是黑③如果节点是红那两个子节点肯定是黑④每个节点到达其可达叶节点的所有路径下的黑色节点数目是一样的。

##### 5.扩容

​	HashMap里面有四个参数（size实际容量、threshold实际最大容量、loadFactor负载因子），threshold为初始化长度乘loadFactor，当添加完一个key后size若大于threshold，则进行扩容操作，扩容两倍，并进行rehash操作。

​	由于在hash寻址的时候进行了优化，求key在数组中的索引是用key的hash值和数组长度N减一做**与运算**，结果只与hash值的后N有关；

故扩容有以下结论：

​	假设数组长度为2的N次方，那key在数组中的索引位置由hash值的后N位有关；

​	扩容后数组长度为2的N+1次方，key在数组中的索引位置由hash值的后N+1有关；

​	在公式`(n - 1) & hash`中n为2的n次方，所以**n-1**转换为二进制数后n位为1，其余都为0，扩容后的**n-1**后n+1位为1，只有第n+1位不同，hash值扩容前后不变，所以做与运算后只有第n+1位不同，只需要判断**与运算**后第n+1的值皆可得出扩容后的位置，为0则放原位置，为1则放原索引的两倍位置。

## 面试

参考：https://zhuanlan.zhihu.com/p/76735726

- 你看过HashMap源码嘛，知道原理嘛?

- 为什么用数组+链表？

- hash冲突你还知道哪些解决办法？

- 我用LinkedList代替数组结构可以么?

- 既然是可以的,为什么HashMap不用LinkedList,而选用数组?

- HashMap在什么条件下扩容?

- 为什么扩容是2的n次幂?

- 为什么为什么要先高16位异或低16位再取模运算?

- 知道hashmap中put元素的过程是什么样么?

  对key的hashCode()做hash运算，计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)； 如果节点已经存在就替换old value(保证key的唯一性)；如果bucket满了(超过load factor*current capacity)，就要resize。

- 知道hashmap中get元素的过程是什么样么？

  对key的hashCode()做hash运算，计算index; 如果在bucket里的第一个节点里直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;

  - 若为树，则在树中通过key.equals(k)查找，O(logn)；
  - 若为链表，则在链表中通过key.equals(k)查找，O(n)。

- 你还知道哪些hash算法？

- 说说String中hashcode的实现?(此题很多大厂问过)

  ```java
  public int hashCode() {
  	int h = hash;
  	if (h == 0 && value.length > 0) {
  		char val[] = value;
  
  		for (int i = 0; i < value.length; i++) {
  			h = 31 * h + val[i];
  		}
  		hash = h;
  	}
  	return h;
  }
  ```

- 知道jdk1.8中hashmap改了啥么?

  - 由**数组+链表**的结构改为**数组+链表+红黑树**。
  - 优化了高位运算的hash算法：h^(h>>>16)
  - 扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。（由于此改变，hashmap在1.8后不会出现死循环问题）

- 为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?

- 我不用红黑树，用二叉查找树可以么?

- 那为什么阀值是8呢?

- 当链表转为红黑树后，什么时候退化为链表?

  为6的时候退转为链表。

- HashMap在并发编程环境下有什么问题啊?

  - (1)多线程扩容，引起的死循环问题
  - (2)多线程put的时候可能导致元素丢失
  - (3)put非null元素后get出来的却是null

- 在jdk1.8中还有这些问题么?

  在jdk1.8中，死循环问题已经解决。其他两个问题还是存在。

- 你一般怎么解决这些问题的？

- 健可以为Null值么?
- 你一般用什么作为HashMap的key?
- 我用可变类当HashMap的key有什么问题?
- 如果让你实现一个自定义的class作为HashMap的key该如何实现？













[^1]: 异或运算(^)，计算机二进制运算的一种，相同为0，不同为1，如0^1为1，1^1为0.
[^2]:与运算(&)，计算机二进制运算的一种，两个都是1为1，其它都为0，如1&1为1，1&0为0，0&0为0.