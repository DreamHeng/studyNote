# JVM(Java Virtual Machine)

## 一.JVM的内存区域

### 1.Java程序具体执行过程

​	首先是我们写的源代码**.java**文件，经过java编译器编译成二进制字节码文件**.class**，然后由JVM的类加载器加载各个类的字节码文件，加载完毕后，交由**JVM执行引擎**执行。在整个程序执行过程中，JVM会使用一段空间来存储程序执行期间用到的数据和相关信息，这段空间一般被称为**Runtime Data Area（运行时数据区）**，也就是我们常说的JVM内存，我们常说的内存管理就是对这段空间进行管理（**如何分配和回收内存空间**）。

![image-20200628221651993](jvm.assets/image-20200628221651993.png)

### 2.运行时数据区的具体划分

​	根据JVM规范，JVM的内存区域应该包括**程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)**。

![image-20200628221842937](jvm.assets/image-20200628221842937.png)

#### 2.1.程序计数器

​	程序计数器是一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器，也就是存储当前执行指令的地址。因为Java多线程是通过线程轮流切换、分配处理器执行时间来实现的，所以每个线程都需要一个单独的程序计数器，保证线程切换后的正确执行。所以说，程序计数器是每个线程私有，互不干扰。

​	如果当前线程执行的是java方法，那么记录的是虚拟机字节码指令的地址；如果是本地native方法，那么记录的是undefined。

​	因为此区域存储数据大小是固定的，所以此区域也是JVM规范中唯一一个不会抛出OutOfMemoryError的内存区域。

#### 2.2.虚拟机栈

​	虚拟机栈也称为Java栈，栈结构，先入后出。

​	虚拟机栈中存的是一个个的**栈帧**，每个栈帧对应一个被调用的方法，在栈帧中包括**局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息**。当线程执行一个方法时，就会创建一个对应栈帧放入栈的顶部。方法执行完毕后，执行出栈。因每次执行一个方法都会创建一个栈帧放入栈中，所以递归操作容易造成**栈内存溢出问题**。这部分空间的分配和释放是由系统自动操作的。

​	![img](https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg)

1. **局部变量表**，存放的是方法的局部变量（包括方法中声明的非静态变量以及函数形参）。对于基本数据类型，存储的是值；对于对象，存储的是引用地址。局部变量表的大小在编译期就可以确定大小了，所以在程序执行过程中局部变量表的大小不会改变；
2. **操作数栈**，用来执行方法的具体计算过程；
3. **指向运行时常量池的引用**，方法执行过程中可能用到类中的常量，该引用即是指向运行时常量；
4. **方法返回地址**，记录方法调用返回的地址。

每个线程执行时调用方法不同，所以每个线程都有各自的虚拟机栈。

在JVM规范中，对虚拟机栈这片区域规定了两种**异常状况**：

1. 如果线程请求的栈深度大于虚拟机锁允许的栈深度，将抛出**StackOverflowError**异常；

2. 如果java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出**OutOfMemoryError**异常。

   注意：HotSport虚拟机的栈容量不可以扩展，所以不会因为第2个原因导致OutOfMemoryError异常；有可能在申请栈空间时就失败。

#### 2.3.本地方法栈

​	本地方法栈和java栈类似，不同的是java栈执行java方法，本地方法栈执行本地方法（native）。在HotSpot虚拟机中将本地方法栈和java栈合二为一。

​	本地方法栈也会抛出java栈中说到的两种异常：**StackOverflowError**和**OutOfMemoryError**。

#### 2.4.堆

​	堆是JVM内存中最大的一块，用来存储对象实例。**所有线程共享**。”几乎“所有的对象实例都在这里被分配内存。JVM规定所有对象和数组都应在堆上分配。但是随着即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙发生，所以此规定也不再那么绝对。

​	Java堆是垃圾收集器管理的内存区域，因为也称为“GC堆”。从回收内存角度来说，由于现代垃圾收集器大部分是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”、“老生代”、“永久代”概念，但这些区域划分只是一部分垃圾收集器的设计风格，**不是**JVM的规范。

​	Java堆的大小可以通过-Xmx和-Xms设定。如果java堆中没有内存完成实例分配，并且堆也无法完成扩展时，JVM会抛出**OutOfMemoryError**异常。

java堆各个区域的划分（TODO）

#### 2.5.方法区

​	方法区也是线程共享，用来存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译之后的代码缓存等数据。方法区经常被人叫做“永久代”，这并不准确，在JDK8之前HotSpot虚拟机的设计团队将垃圾收集器的粉黛设计扩展到方法区，或者说使用永久代来管理方法区，故称为“永久代”，但不是所有虚拟机都这样处理，其它虚拟机有的并没有“永久代”这一概念，**且在JDK7后HotSpot将字符串常量池、静态变量（事实是移到了Class对象中，Class对象如同其他对象一样在堆中）移到java堆中，JDK8后废除了“永久代”概念并将运行时常量池、类型信息移到了元空间**，所以该说法不准确。

#### 2.6.运行时常量池

​	运行时常量池是方法区的一部分，JDK8后HotSpot将此移到了元空间。

​	在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。**运行时常量池**是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

​	常量池内存无法申请时会爆出**OutOfMemoryError**异常。

#### 2.7.元空间

​	元空间（Meta-space）是JRockit、J9对方法区的实现，HotSpot在JDK8后也是使用此实现设计。

​	元空间与方法区（HotSpot的“永久代”）最大区别在于，元空间是在本地内存中实现的。

#### 2.8.直接内存（TODO）

### 3.JVM的运行过程

​	把系统放入web服务器系统（如tomcat）中，会通过加载类启动类加载器，把类放入元空间，spring框架中通过反射技术创建bean实例对象放入堆中。当有客户端发起请求时，通过一个线程创建出独有的内存区域（程序计数器和两个栈空间），在栈中不断创建栈帧调用方法，操作数栈，引用堆空间的实例对象，执行类的方法，失去引用的对象会被GC回收。

![image-20200629000342090](jvm.assets/image-20200629000342090.png)

## 二.垃圾收集

​	垃圾收集（Garbage Collection，简称GC），就是指把垃圾内存收回。

​	在《深入理解JAVA虚拟机》一书中关于垃圾收集有三个要点：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

### 1.哪些内存需要回收？”已死“的对象内存

​	”已死“对象表示不会再被任何途径使用的对象，需要回收的内存就是存放这些对象的内存。如何判断是否“死去”呢？有两种算法判断：**引用计数算法**，**可达性分析算法**。

#### 1.1.引用计数算法

​	引用计数算法是在对象中添加一个引用计数器，当被引用的时候+1，失去引用的时候-1，当计数器为0的时候代表没被任何途径引用，代表”死去“。引用计数算法有一定的漏洞，比如两个对象循环引用，两个对象实际都不可能被访问，但因为两者相互引用，所以计数器不为0，不会被判断”死去“。

​	引用计数算法虽然有一定漏洞，也需要占有额外的内存空间，但简单高效，使用起来很方便。但java不是使用该算法来判定对象是否”死去“的。

#### 1.2.可达性分析算法

​	可达性分析算法是java、c+等多门商用程序语言用来判定对象是否”存活“的算法。

​	可达性分析算法的基本思路是通过一系列被称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为引用链（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者说路径不可达，那么此对象是不可能被使用的。

​	在java中被当做GC Roots的对象朱啊哟是非堆里面的对象，如java栈里面的局部对象引用，本地方法栈里面的对象引用，以及一些Class对象引用，元空间的常量池。

#### 1.3.二次标记

​	在可达性分析算法里面被标记为不可达对象并不是非死不可，他们会被做上一次标记，真正的死亡，至少需要经过两次标记。JVM会对经过一次标记的对象进行再次筛选，若调用了finalize()方法，则放入一个叫F-Queue的队列里面，没有调用，或者已经被调用过一次，就再次标记清除。稍后JVM会另外起一个线程执行队列里面的finalize()方法，若对象在该方法中被重新引用，那么久被免于清除，若没有重新引用，则被清除，JVM不保证该方法一定会运行完毕，所以，此方法不建议使用。

### 2.什么时候回收？垃圾回收算法判定

​	垃圾回收算法是用来判定什么时候回收垃圾内存的。常见的垃圾回收算法有**标记-清除算法**、**复制算法**、**标记-整理算法**、**分代收集算法**。大部分虚拟机使用的都是**分代收集算法**。

#### 2.1.分代收集理论

​	当前商用的虚拟机都是遵循了分代收集理论，即是把java堆分为几个不同的区域，然后根据收集对象的年龄分到不同的区域（年龄是指熬过垃圾收集过程的次数）。一般是把java堆分为**新生代**和**老年代**，新生代指的是每次回收都会有大量对象死去，熬过多次的会逐渐晋升到老年代。

​	分代收集理论有几个收集的概念：

- 部分收集（Partial GC），指目标不是实现整个java堆的垃圾收集，而是部分收集，其中又分为：
  - 新生代收集（Young GC/Minor GC），只是新生代垃圾收集；
  - 老年代收集（Old GC/Major GC），只是老年代收集。目前只有CMS收集器会单独收集老年代的行为。
  - 混合收集（Mixed GC），收集整个新生代和部分老年代的垃圾，目前只有G1收集器会有这种行为。

- 整堆收集（Full GC），收集整个java堆和方法区的垃圾收集。

#### 2.2.标记-清除算法（Mark-Sweep）

​	顾名思义，就是把垃圾对象标记起来，然后清除，此算法会造成很多内存碎片。

#### 2.3.复制算法（Copying）

​	标记-复制算法被简称为复制算法，是将内存区域分为大小相同的两块A、B，每次只使用一块区域A，当该清除对象时，将存活的对象复制到另外一块区域B，然后将区域A的所有对象都清除。该算法经常被用在新生代中，HotSpot虚拟机中默认A:B:B的比例为8:1:1，A区域被称为Eden区域，B区域会有两个，称为Survivor区域。

#### 2.4.标记-整理算法（Mark-Compact）

​	标记-整理算法在实行时会停掉正常的程序操作，称为“Stop The World”，把存活的对象移到内存空间的一端，整体清除到这一端的另外一部分，该清除算法花销代价较大，所以通常被用到老年代中。

#### 2.5.分代收集算法（Generational Collection）

​	分代收集算法是根据不同的内存区域使用不同的清除算法，大部分虚拟机都是采用此算法，在新生代使用复制算法，老年代使用标记-整理算法。

### 3.如何回收？垃圾回收器

​	垃圾收集器是垃圾回收算法的具体实现。

#### 3.1. Serial/Serial Old

​	最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。

#### 3.2. ParNew

​	Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集。

#### 3.3. Parallel Scavenge

​	新生代的并行收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。

#### 3.4. Parallel Old

​	Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程。

#### 3.5. CMS

​	Current Mark Sweep收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用Mark-Sweep算法。

#### 3.6. G1

​	G1(Garbage First)收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。